* Bugs
** DONE (Ulrik) The optimizer does not propagate constants to output functions.
*** TODO Test that this works now.


* Features
** DONE [#B] Limit constant propagation
*** Description:
   Propagating constants seem to introduce a lot of copying in cases such as
   ``abcd|[a-z]*''. Essentially, the bit-codes for a, ab, and abc parsed using
   ``[a-z]*'' are included as constants in the "optimized" SST.  Maybe the
   static analyzer is too eager. An alternative approach could work as follows:

   When the analyzer currently encounters an assignment of the form x <- C[x]
   where C[.]  is a constant context and the value of x is statically known to
   be some `v', the static value of x is updated to C[v]. This might be too
   eager, consider the following:

   1 : x <- 1010
       y <- 1
       goto 2
   2 : x <- x y 0
       y <- 0
       if .. { write(x); accept() } else goto 3
   3 : x <- x y 1
       if .. { write(x); accept() } else goto 4
   4 : ...

   Assuming that block 1 is not reachable from block 4, this will be "optimized"
   to

   1 : goto 2
   2 : if .. { write(101010); accept() } else goto 3
   3 : if .. { write(10101001); accept() } else goto 4
   4 : ...

   We eliminated both x and y, but we have repeated the value "10101". This is
   exactly what happens for expressions of the form ``w|[a-z]*'', and will lead
   to |w| constants in the program, each a prefix of the next.

   We should try to change the static analysis such that dynamic updates are not
   eliminated, but assign-once constants are. This means that in the above
   example, the x buffer will be left intact, but the y buffer is eliminated,
   since it is only assigned once and never updated using itself as input.
*** Status:
  When optimizing at level < 3, the static analyzer will consider all variables
  depending on themselves as ambiguous.
